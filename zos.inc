ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ;;; software interrupt infrastructure the OS is based on (with interrupts off!)
;;; user-definable:
ZOS_SB7	equ	7
ZOS_SI7	equ	(1<<ZOS_SB7)
ZOS_SB6	equ	6
ZOS_SI6	equ	(1<<ZOS_SB6)
ZOS_SB5	equ	5
ZOS_SI5	equ	(1<<ZOS_SB5)
ZOS_SB4	equ	4
ZOS_SI4	equ	(1<<ZOS_SB4)
ZOS_SB3	equ	3
ZOS_SI3	equ	(1<<ZOS_SB3)
;;; system:
ZOS_FND	equ	0x07		; find a running job by its handle AR1:AR0
ZOS_EXE	equ	0x06		; replace this job with a new job (unpriv'ed)
ZOS_FRK	equ	0x05		; copy a running job into a new job
ZOS_YLD	equ	0x04		; (in)voluntarily cede processor before next irq
ZOS_RST	equ	0x03		; restart job at its start address (vs. END+NEW)
ZOS_END	equ	0x02		; job killed, slot# available for NEW
ZOS_SLP	equ	0x01		; indicate job waiting on its ISR, so don't run
ZOS_NEW	equ	0x00		; create a job (FSR0==addr,AR1:0==isr,AR3:2==IM)
;;; FND runs high->low, _END/_SLP/_RST can only be run by a _PRV job or *it* got

;;; you may redefine a constant ZOS_NUM with the maximum job number (<6,
;;; as determined by where the general purposes register memory stops)
 ifdef (ZOS_NUM)
 else
ZOS_NUM	set	5
 endif
	
;;; bank 0 memory space for managing jobs, 1@0x20, 2@0x30, ... , 5@0x60
ZOS_MEM	macro	fsrnum,job,offset
	local	fsrn
	if (fsrnum & 3)
fsrn set 1
	else
fsrn set 0
	endif
	swapf	job,w
	addlw	0x10
	andlw	0x70
	if (offset)
	 addlw	offset
	endif
	movwf	FSR#v(fsrn)L
	clrf	FSR#v(fsrn)H
	endm
ZOS_J1M	equ	0x20
ZOS_J2M	equ	0x30
ZOS_J3M	equ	0x40
ZOS_J4M	equ	0x50	
ZOS_J5M	equ	0x60	
ZOS_BOS	equ	0x0b		;// right?
	
;;; job/shadow register offsets from ZOS_J0M, ZOS_J1M,...
ZOS_HDL	equ	0x00		; handle, the start address of the job
ZOS_HDH	equ	0x01		;
ZOS_PRB	equ	7		;  MSB of HDL indicates privilege(manage others)
ZOS_PRV	equ	(1<<ZOS_PRB)	;
ZOS_PCL	equ	0x02		; address to resume execution
ZOS_PCH	equ	0x03		;  "impossible" PCH 0x00==not runnable
ZOS_WAI	equ	7		;  MSB of PCH indicates sleeping (wait for int)
ZOS_SST	equ	0x04		; shadow STATUS
ZOS_SWR	equ	0x05		; shadow WREG
ZOS_SSP	equ	0x06		; STKPTR to be restored (BSR never restorable!)
ZOS_SPH	equ	0x07		; PCLATH to be restored
ZOS_SF0	equ	0x08		; shadow FSR0
ZOS_SF1	equ	0x0a		; shadow FSR1
ZOS_ISR	equ	0x0c		; interrupt service routine address for the job
ZOS_ISH	equ	0x0d		; interrupt service routine address for the job
ZOS_HIM	equ	0x0e		; mask for hardware interrupts to process (0=no)
ZOS_SIM	equ	0x0f		; mask for software interrupts (low 3 always==1)
	
;;; global memory space for message-passing boxes (or J6M?!?)
ZOS_JOB	equ	0x70		; next job to run (0 if unknown)
ZOS_MSK	equ	0x71		; masked-off sofware interrupt for ISR to handle
ZOS_TMP	equ	0x71		;  (repurposeable as scratch after ZOS_RFI call)
ZOS_J1L	equ	0x72
ZOS_J1H	equ	0x73
ZOS_J2L	equ	0x74
ZOS_J2H	equ	0x75
ZOS_J3L	equ	0x76
ZOS_J3H	equ	0x77
ZOS_J4L	equ	0x78
ZOS_J4H	equ	0x79
ZOS_J5L	equ	0x7a
ZOS_J5H	equ	0x7b
	;; must disable interrupts e.g. with ZOS_ARG(0) before writing SWI args:
ZOS_AR0	equ	0x7c
ZOS_AR1	equ	0x7d
ZOS_AR2	equ	0x7e
ZOS_AR3	equ	0x7f

	org	0x0000
	pagesel	zos_ini
	goto	zos_ini

	org	0x0002
	pagesel	zos_swj
	goto	zos_swj

;;; when searching for the correct hardware interrupt handler, without stack hit
ZOS_RET	macro
	pagesel	?
	goto	? ;to next iteration of search
	endm

;;; at the end of any interupt handler, goes back to scheduler without stack hit
ZOS_RFI	macro	
	pagesel	zos_sch
	goto	zos_sch
	endm

	;; a job switch is attempted with every incoming interrupt
	;; user jobs are responsible for processing their own interrupts
	;; with an interrupt handler registered at the time of creation
	org	0x0004
	;; handle a hardware interrupt
	clrf	ZOS_MSK		; ZOS_MSK = 0; // indicates a hardware type

zos_sch
	;; copy this job's criticals into its bank 0 backing store

	;; look for the next runnable job

	;; 

	;; software interrupt processing
zos_swj
	;; save the shadow registers (for the ones that have them)
	banksel	WREG_SHAD
	movwf	WREG_SHAD	; // the software interrupt type
	movf	STATUS,w
	movwf	STATUS_SHAD
	movf	BSR,w
	movwf	BSR_SHAD	; // the job# that made the interrupt call
	movf	PCLATH,w
	movwf	PCLATH_SHAD
	movf	FSR0L,w
	movwf	FSR0L_SHAD
	movf	FSR0H,w
	movwf	FSR0H_SHAD
	movf	FSR1L,w
	movwf	FSR1L_SHAD
	movf	FSR1H,w
	movwf	FSR1H_SHAD
	movf	FSR1H_SHAD,w
	movwf	BSR		; // BSR back to what it used to be

	;; see if the interrupt type is a system one (<8)
	movlp	zos_swh
	movlw	ZOS_SI7|ZOS_SI6|ZOS_SI5|ZOS_SI4|ZOS_SI3
	andwf	WREG_SHAD,w	; if (0 == /* call-type number: */ WREG_SHAD &
	btfss	STATUS,Z	;   (ZOS_SI7|ZOS_SI6|ZOS_SI5|ZOS_SI4|ZOS_SI3)) {
	goto	zos_swh		;  // handle a system ZOS_SWI call:

	;; ZOS_NEW requires us to search for a BSR value first among empty slots
	movf	WREG_SHAD,f	;
	btfss	STATUS,Z	;
	bra	zos_swp		;  if (ZOS_NEW == WREG_SHAD) {
	clrf	ZOS_JOB		;   zos_job = 0;
	ZOS_MEM	FSR1,ZOS_JOB,0
zos_emp
	movlw	0x10		;   for (fsr1 = 0x10*(1+zos_job);
	addwf	FSR1L,f		;
	incf	ZOS_JOB,f	;        zos_job++ <= ZOS_NUM;
	movlw	0xff-ZOS_NUM	;
	addwf	ZOS_JOB,w	;
	btfsc	STATUS,Z	;        fsr1 += 10) {
	bra	zos_err		;    if (ZOS_PCH[FSR1] == 0)
	moviw	ZOS_PCH[FSR1]	;     break;
	btfss	STATUS,Z	;   }
	bra	zos_emp		;   if (zos_job <= ZOS_NUM) {
	movf	FSR0L,w		;    // save handle now so we can re-use fsr0
	movwi	ZOS_HDL[FSR1]	;    // (no harm if we don't validate it as PCH)
	movf	FSR0H,w		;    ZOS_HDL[fsr1] = fsr0 & 0x00ff;
	movwi	ZOS_HDH[FSR1]	;    ZOS_HDH[fsr1] = fsr0 >> 8;
	movf	BSR,f		;    if (bsr == 0)
	btfsc	STATUS,Z	;     goto zos_swk; // job#0 (launcher) has perm
	bra	zos_swk		;    fsr0 = 0x10 * (1+bsr); // struct for caller
	ZOS_MEM	FSR0,BSR,0
	moviw	ZOS_HDH[FSR0]	;    if (ZOS_HDH[fsr0] & ZOS_PRV)
	btfsc	WREG,ZOS_PRB	;     goto zos_swk; // job has privileged perms
	bra	zos_swk		;   }
zos_err	
	clrf	ZOS_JOB		;   zos_job = 0; ZOS_RFI(); // perm/full error!
	ZOS_RFI
	
	;; see if we're not running inside a job context (1 <= job# <= ZOS_NUM)
	;; in which case need to grab the targeted job from AR0 (if not ZOS_NEW)
	;; or find a targetable slot (if ZOS_NEW)
	;; unprivileged jobs can only do most things to themselves
zos_swp
	movf	BSR,f		;  } else {
	btfss	STATUS,Z	;   if (bsr != 0) {
	bra	zos_elv		;    fsr1 = 0x10 * (1+bsr); // struct for job
	ZOS_MEM	FSR1,BSR,0
	moviw	ZOS_HDH[FSR1]	;    if (ZOS_HDH[fsr1] & ZOS_PRV == 0)
	btfss	WREG,ZOS_PRB	;     goto zos_swk;
	bra	zos_swk		;   }
	
	;; desired job# (instead of this one) into BSR from AR0 (if not ZOS_NEW)
zos_elv
	movf	ZOS_AR0,w	;   // access granted, bring the patient to me
	movwf	BSR		;   bsr = ZOS_AR0;
zos_swk
	movf	WREG_SHAD,w	;  }
	brw			;
	bra	zos_sw0		;
	bra	zos_sw1		;
	bra	zos_sw2		;
	bra	zos_sw3		;
	bra	zos_sw4		;
	bra	zos_sw5		;
	bra	zos_sw6		;
	bra	zos_sw7		;  switch (WREG_SHAD) { // guaranteed < 8
zos_sw0
	moviw	ZOS_HDL[FSR1]	;  case ZOS_NEW:
	movwi	ZOS_PCL[FSR1]	;   ZOS_PCL[fsr1] = ZOS_HDL[fsr1];
	moviw	ZOS_HDH[FSR1]	;   // retain HDL MSB (which indicate privilege)
	andlw	0x7f		;   // clear PC MSB (which indicates sleepiness)
	movwi	ZOS_PCH[FSR1]	;   ZOS_PCH[fsr1] = ZOS_HDH[fsr1] & 0x7f;
	movlw	ZOS_BOS		;   ZOS_SSP[fsr1] = ZOS_BOS;
	movwi	ZOS_SSP[FSR1]	;
	movf	ZOS_AR0,w	;   ZOS_ISR[fsr1] = ZOS_AR0;
	movwi	ZOS_ISR[FSR1]	;
	movf	ZOS_AR1,w	;   ZOS_ISH[fsr1] = ZOS_AR1;
	movwi	ZOS_ISH[FSR1]	;
	movf	ZOS_AR2,w	;   ZOS_HIM[fsr1] = ZOS_AR2;
	movwi	ZOS_HIM[FSR1]	;
	movf	ZOS_AR3,w	;   ZOS_ISR[fsr1] = ZOS_AR3;
	movwi	ZOS_SIM[FSR1]	;   ZOS_RFI();
	ZOS_RFI
zos_sw1
	moviw	ZOS_PCH[FSR1]	;  case ZOS_SLP:
	iorlw	0x80		;   ZOS_PCH[fsr1] |= 0x80;
	movwi	ZOS_PCH[FSR1]	;   ZOS_RFI();
	ZOS_RFI
zos_sw2
	clrw			;  case ZOS_END: ZOS_PCH[fsr1] = 0;
	movwi	ZOS_PCH[FSR1]	;   ZOS_RFI(); // killing is so quick
	ZOS_RFI
zos_sw3
	mov